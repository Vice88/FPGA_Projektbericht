%%document preambel

\documentclass{scrartcl}
\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{beramono}% monospaced font with bold variant

%\usepackage{listings}
%\lstdefinelanguage{VHDL}{
%  morekeywords={
%    library,use,all,entity,is,port,in,out,end,architecture,of,
%    begin,and
%  },
%  morecomment=[l]--
%}
%
%\usepackage{xcolor}
%\colorlet{keyword}{blue!100!black!80}
%\colorlet{comment}{green!90!black!90}
%\lstdefinestyle{vhdl}{
%  language     = VHDL,
%  basicstyle   = \ttfamily,
%  keywordstyle = \color{keyword}\bfseries,
%  commentstyle = \color{comment}
%}


\begin{document}

\title{Partial reconfiguration and fault simulation with Altera Cyclone V FPGA}
\subtitle{Students project at the chair of computer architecture university freiburg}
\author{Markus Weiß}
\maketitle
\tableofcontents
\newpage

\section{HW/SW prerequisite for this project}
The Hard- and Software prerequisites are the same for both projects, so here is a short summary of the used hard- and software.
\subsection{Hardware}
The hardware used in this project were a "Terasic DE1-SoC Development Kit".  This development kit consists of the following core components: a FPGA, named Altera Cyclone V FPGA (5SCEMA5F31C6N), a dual-core Cortex-A9 (HPS), 1GB DDR3 and 64MB SDRAM and different interfaces (USB,JTAG,i2c). The communication interfaces are a on board USB-Blaster II, USB 2.0 ports, UART interface, Ethernet port and extended module for gpio pins.\\
The fpga is the mainly used component of the development kit board. Here are some useful facts about the fpga Cyclone V:\\
\begin{itemize}
	\item 85000 logic cells on the board
	\item 4450 kb embedded memory
	\item access to an external 64 MB static random access memory (SRAM)
	\item low energy consumption
	\item standard clock frequency is 50 MHz
\end{itemize}
The Cyclone V is configured with a JTAG interface, where a bit stream is loaded to the board. This bit stream is lost once the energy is off. Also available is the option to program an in-system NOR flash memory, which safes the bit stream while power is taken off.\\ Another way to program the fpga is to use the HPS. This is done while the boot process with "U-Boot" or the "preloader", but it also works if the operating system is fully booted.\\ The \textbf{preloader} initiates the clock, multiplexing of pins, configuration of the main memory and load the U-Boot.  The configuration of the main memory of the HPS and the AXI Bridges is important, because these have to grant the fpga access.\\ The \textbf{universal boot loader} initiates and tests hardware components. Also it downloads and executes application software. This boot-loader is required to initiate the boot process of the UNIX-kernel. \\ The \textbf{Avalon-Memory-Mapped-Interface} enables efficient read- and write operations, interrupts, clocks, resets and control progresses. This Avalon-MM-Interface enables address based read- and write procedures in a master/slave connection. The master put a request to the slave, which read or write special addresses of the memory. This interface is required to get access from the FPGA to the main memory of the HPS.\\ To work with an external C/C++ program an operation system for the hps is needed. The chosen OS is a linux system.


\subsection{Software}
The software used in this project were Quartus II Version 14.1/15.0 and QSYS on Windows 7/8.1.\\Quartus II is needed to generate VHDL- or Verilog programs which can be used by a FPGA. The software can be configured to reach different design goals, e.g. time complexity, speed, optimization of compilation time or energy consumption.\\ QSYS is described as a tool for system integration to safe time, therefore cost of developer by generating automatic connection-logic of different components. The developed VHDL code from Quartus II software can be imported to QSYS to connect different components, e.g. on the DE-SoC1. QSYS has to initiate, configure and connect the HPS to the FPGA if they have to communication between each other.

\section{Partial reconfiguration}
\subsection{The idea and the benefit of partial reconfiguration}
The idea of partial reconfiguration is highly desirable for some special purposes. With this feature it is easier to change designs or improve the the functionality without stopping its working progress. Some applications need to change some logic while another part is not allowed to stop, e.g. the flow of data. Therefore this function is desirable in the field of communication systems and high-performance computing platforms. A benefit of this idea is that the number of devices can be scaled down, therefore the power consumption and of course the cost. The tasks another fpga has handled before can now be handled by the same fpga, only another part of the logic cells take this. \\Thanks to this feature the fpga can handle a new input while another part still executes its commands.\\
This reconfiguration is initialized by an external processor on the development kit (hps) and programs the desired locig cells of the fpga while the other part remains in its process. The initiation is done by an internal host which runs a C/C++ program. This C/C++ program is stored in the RAM (read access memory) of the development kit board.\\
Partial reconfiguration could be combined with the fault simulation on fpga for a  efficient way to detect logic errors.

\subsection{Design flow and implementation of partial reconfiguration}
The focus of the partial reconfiguration is rather on logic blocks than DSP, memories, PLL, transceivers and I/O blocks. Functions in the periphery like GPIO or I/O registers can not be partially reconfigured.\\ There have to be two different regions in the top level design, one static and one region for the partial reconfiguration. Two led pattern are loaded to this regions. One pattern, in the static region, highlights the leds to check if the fpga is still running while another led pattern is loaded to the dynamic or partial reconfiguration region which let us check if a part of the fpga is reconfigured. \\
A wrapper region is generated to ensure that all of the PR personas have the same connection to the static region. This is done by creating dummy ports.\\
For partial reconfiguration all non-global inputs of the pr regions must be freezed. Freezing means in this context to drive a '1' to the inputs which ensures there is no contention between current values and those after partial reconfiguration. Therefore a freeze region is created.\\The projects idea was a partial reconfiguration with an internal host, which initializes the reconfiguration with a c/c++ program. To do so, the processor has to communicate with the fpga and with the memory. The communication between the hard processor system and  the fpga, the main memory and in- and output interfaces is a crucial point.  The design flow used in this project was as follows:
\begin{enumerate}
	\item planning the system for partial reconfiguration
	\item identify which blocks to be partially reconfigured $\rightarrow$ led pattern for the led on DE1-SoC board
	\item code the design in Quartus II
	\item develop the personas
	\item generate static and pr region
	\item assign partitions to logiclock regions
	\item create necessary files to program fpga
	\item program fpga 
\end{enumerate}
The FPGA development process is done by Quartus II and QSYS. Quartus II creates the FPGA components in VHDL, while QSYS connects different system components which communicate and access each other. This informations are required to generate the "preloader" which coordinates the boot process. The next step of booting is the "universal boot loader" which configures the fpga and load the "linux-kernel". The Avalon-MM-Interface is required to grant the fpga access to the main memory of the HPS.\\
\textbf{Partial reconfiguration is not supported by the Cyclone V fpga} which yields to stop the project.
%Two different led pattern, a wrapper and a freeze region were designed. The design partition were associated with the logiclock regions of the fpga
%	\item connect I/O signals with pins (QSYS)


%There are different options for the communication between HPS and FPGA, which are mentioned here without a detailed description. 
%\begin{enumerate}
%	\item Advanced extensible interface bus bridges (AXI)
%	\begin{enumerate}
%		\item Lightweight HPS-to-FPGA bridge
%		\item HPS-to-FPGA bridge
%		\item FPGA-to-HPS bridge
%	\end{enumerate}
%	\item FPGA-to-SDRAM
%\end{enumerate}

%\\ Project design flow, hierarchy etc, code citation.
%Which design blocks are necessary to program the fpga for partial reconfiguration. Wrapper, logic, etc. ...comment on created code.

\subsection{Reason why the project was stopped}
After working eight weeks in the field of partial reconfiguration the project has to be stopped. Following problems occurred:
\begin{itemize}
	\item  no permission to use partial reconfiguration feature in Quartus Software; so a new license was inquired.
	\item the fpga Cyclone V does not support the feature of partial reconfiguration; this hardware problem could not be solved because a new special fpga was not affordable for the chair
\end{itemize}
The status quo at the time of cancellation was:
\begin{itemize}
  \item literature survey
  \item soft- and hardware prerequisites
  \item project design flow
  \item creating different revisions for partial reconfiguration in Quartus II
  \item VHDL design
	\begin{itemize}
		\item top level
		\item wrapper
		\item freeze region
		\item static region + personas
		\item partial reconfiguration region + personas
	\end{itemize}
  \item pin assignments
  \item file creation for programming the fpga (.pmsf, .msf, .sof, .rbf)
\end{itemize}

%\subsection{Discussion}
%Partial reconfiguration can be used in time critical systems, like communication systems where a abrupt stop of a data flow is critical. The field of partial reconfiguration is still a new topic to researcher. It is not integrated in industrial products yet, because if a special fpga is needed instead of an ASIC it is not very cost efficient. The absence of a proper fpga for partial reconfiguration forced the project to be stopped.

\section{Fault simulation}
\subsection{Idea of fault simulations on fpga}
The idea of fault simulation is to detect stuck-at faults with the fpga. A special test pattern is loaded to the ram of the fpga. This is done by the communication from pc to the fpga via usb blaster. The circuit under test is realized by one circuit without fault pattern and one with changed lcells. The changed logic cells are loaded with test pattern to compare both. The output of both circuits is lead to a logical XOR gate. If the outputs of both circuits distinguishes the XOR gate give a logical one, hence a fault. Otherwise no fault is detected. This output is saved in a fifo and then transmitted to the pc for documentation purposes via the serial interface RS232.
%Efficient fault simulation in hardware FPGA. modification of the circuit with special changes to the look up tables. evaluation and pc communication with serial interface rs232.\\
%To detect faults some lcells are modified. 
% \textbf{lcell}
% \begin{itemize}
%	\item smallest logic cell
%	\item maximal four inputs
%	\item gatter are ordered in a logic cell
%	\item every lcell have a look-up table, which defines the output
%	\item the function of a particular  lcell can be changed by hand
%\end{itemize}
The idea of the Maximum fanout free cones (MFFC), adopted from a former project,   is to assign as many as possible gates to one logic cell. The creation of maximum fanout free cones is an algorithm to minimize the number of gates in one logic cell. This algorithm is implemented in quartus by a former work. The original circuit under test is compared to a modified circuit. The look-up table (LUT) can be calculated for every locig cell in quartus. The idea of the fault injection test is an efficient way to detect faults in hardware. The evaluation is done over the rs232 interface and a personal computer. The goal is a very fast way to detect those faults.

\subsection{Special software requirements}
In addition to the mentioned software in the beginning some special software is required:
\begin{itemize}
	\item C++ compiler e.g. MinGW
	\item USB driver for USB Blaster
\end{itemize}
Also it seems to be intuitive to install USB driver, it was quite difficult to install under Win 8.1 becuase the delivered driver has no driver signature which is required for Win 8.1. To install a driver without signature you have to follow these steps to install it anyway.
\begin{enumerate}
	\item ...
\end{enumerate}
\subsection{preparation to execute the fault simulation on the development kit}
After setting up the software prerequisites you have to change the absolute paths  inside the C++ files to the desired programs. This list shows the process to execute the fault simulation on the fpga: 
\begin{enumerate}
	\item open 'FaultInjectionTester.qar' with Quartus II
	\item compile this project
	\item close Quartus II
	\item open command window and change directory to FaultConfiguration
	\item execute: \textit{g++ IRA.cpp CGate.cpp CGate.h CComponent.h -o ..IRA.exe}
	\item open command window and change directory to FPGACommunication
	\item execute: \textit{g++ FaultInjectionTester.cpp PcFPGACommunication.cpp PcFPGACommunication.h -o .."FaultInjectionTester.exe"}
	\item Connect board and pc via USB Blaster to programm
	\item connect board and pc via RS232 to communicate
\end{enumerate}
\subsection{process}
\begin{enumerate}
	\item compile quartus project
	\item create IRA.exe in root folder (make.batch file)
	\item create FaultInjectionTester.exe in root folder (make.batch file)
	\item execute IRA.exe [path to quartus], e.g. IRA.exe "C://Program Files//Altera"), beware of whitespaces then you have to write double frontslash, otherwise normal frontslash would be enough.
\end{enumerate}
If it all work well, the pc programms the fpga and tests it over the RS232 communication interface. \\
explain the complete process:
\begin{enumerate}
	\item TCL script
	\item batch
	\item quartus project
	\item c++ files
	\item exe files
	\item vhdl files
\end{enumerate}
Otherwise following common erros occur:
\begin{itemize}
	\item Inconsistent set or reset compile started variable - clear out db and incrementaldb folder in FaultInjectionTesterrestored folder and recompile quartus project
	\item Can not find quartuscdb - if quartus is not installed on C: you have to change the HDD constant in FPGACommunication/PcFPGACommunication.cpp and FaultConfiguration/IRA.cpp to the drive where your quartus is installed.
\end{itemize}
\subsection{Implementation}
approach, vorgehensweise -> adaption of the previous work. 
was man alles beachten muss, was man alles aendern muss...
pfade aendern, treiber installieren (-> nicht trivial !!), tcl, batch, c programm, vhdl, qsys, quartus programm verstehen, was was macht. design flow, work flow, compilation.
what to do... what changed... 

\subsection{Problems}
absolute path to installed software. troubleshooting for installation of usb blaster driver. debugging former code fractions. error in design flow (compilation missing after changing luts). creating batch file to automate it. relative paths to automate. further improvements: design for a virtual machine, version control. 
\subsection{Discussion}
what can be changed, what is the point of work, what are the next steps. Which problems can be solved how? All in all i can say to work on a proper design it is very difficult. The communication link between RS232 and Baord work properly, but without the information on the Version of used software (quartus, qsys, operating system etc.) it is too difficult. Also the installation path should not be absolute. There were an error that the project was not compiled after changing the LUTs. Debugging and troubleshooting took too long to stay focused and motivated to this project. 


% \include{AppendixPR}
\end{document}
